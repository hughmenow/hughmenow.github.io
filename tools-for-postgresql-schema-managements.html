<!DOCTYPE html><html lang="en" dir="ltr"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta http-equiv="X-UA-Compatible" content="ie=edge"><title>Tools for PostgreSQL Schema Managements | Hugh Garnier de Blog</title><meta name="description" content="Learn how to use these powerful migration tools to manage your database schema changes."><link rel="shortcut icon" href="/assets/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/favicon.ico" type="image/x-icon"><link href='/feed.xml' rel='alternate' type='application/atom+xml'><link rel="canonical" href="https://hughmenow.github.io/tools-for-postgresql-schema-managements"><link rel="stylesheet" href="/assets/style.css"><body><main><h2 class="title">Hugh Garnier de Blog</h2><nav> <a href="https://hughmenow.github.io">Home</a> <a href="https://hughmenow.github.io/about">About</a></nav><h1>Tools for PostgreSQL Schema Managements</h1><i>Feb 05, 2023</i><h4 class="subtitle"></h4><p>The article titled <a href="https://www.sisson.ru/managing-database-schema-changes-efficiently.php">Managing Database Schema Changes Efficiently</a> raises a critical issue in software development - managing database schema changes. As a software developer, I have come across this problem on multiple occasions, and I agree with the author’s perspective on the subject.</p><p>In today’s fast-paced software development industry, changes in database schema are a common occurrence. However, these changes can be challenging to manage, especially when multiple developers are working on the same project. It is, therefore, essential to have a streamlined process for managing database schema changes.</p><p>One approach suggested in the article is to use a version control system such as Git to manage changes to the database schema. This approach ensures that changes to the schema are tracked, and the history of the changes is maintained. This is a good practice and one that I have used in the past.</p><p>Another useful approach suggested in the article is to use a database migration tool to manage database schema changes. These tools enable developers to write scripts that make changes to the database schema and track the changes made. The advantage of using a migration tool is that the changes can be applied in a controlled manner, and developers can easily roll back changes if required.</p><p>One database <a href="https://www.sisson.ru/managing-database-schema-changes-efficiently.php#rdbm">migration tool</a> that I have adopted after reading the article mentioned is Schema Guard. It is a database migration tool that allows developers to manage database schema changes using SQL scripts. It tracks the changes made to the database schema and ensures that the changes are applied in the correct order.</p><p>Here is an example of how Schema Guard can be used to manage database schema changes:</p><p>Assume we have a table named “customer” with the following schema:</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">customer</span> <span class="p">(</span>
    <span class="n">id</span> <span class="nb">SERIAL</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
    <span class="n">name</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
    <span class="n">email</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span> <span class="k">UNIQUE</span> <span class="k">NOT</span> <span class="k">NULL</span>
<span class="p">);</span>
</code></pre></div></div><p>Now, let’s say we want to add a new column called “address” to the “customer” table. We can do this using the following SQL script:</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">customer</span> <span class="k">ADD</span> <span class="k">COLUMN</span> <span class="n">address</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">;</span>
</code></pre></div></div><p>We can save this SQL script in a file named “V1__Add_address_to_customer_table.sql”. The “V1” prefix indicates that this is the first version of the database schema. We can then use the app to apply this change to the database schema by running the following command:</p><div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rdbm migrate
</code></pre></div></div><p>This will apply the changes to the database schema, and Schema Guard will update its metadata table to record that the “V1” script has been applied.</p><p>Now, let’s say we want to make another change to the database schema by adding a new table named “orders.” We can create a new SQL script with the following code:</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">orders</span> <span class="p">(</span>
    <span class="n">id</span> <span class="nb">SERIAL</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span> 
    <span class="n">customer_id</span> <span class="nb">INTEGER</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span> 
    <span class="n">order_date</span> <span class="nb">DATE</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span> 
    <span class="n">total_amount</span> <span class="nb">DECIMAL</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span> 
    <span class="k">FOREIGN</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">customer_id</span><span class="p">)</span> <span class="k">REFERENCES</span> <span class="n">customer</span><span class="p">(</span><span class="n">id</span><span class="p">)</span>
<span class="p">);</span>
</code></pre></div></div><p>We can save this SQL script in a file named “V2__Create_orders_table.sql”. The “V2” prefix indicates that this is the second version of the database schema. We can then use Schema Guard to apply this change to the database schema by running the following command:</p><div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rdbm migrate
</code></pre></div></div><p>This will apply the changes to the database schema and update tool’s metadata table to record that the “V2” script has been applied.</p><p>As we continue to make changes to the database schema, we can create new SQL scripts and apply them using Schema Guard. It will ensure that the changes are applied in the correct order and that the history of the changes is maintained.</p><p>Another important concept to consider when managing database schema changes efficiently is version control. Just as code changes are tracked and managed through version control systems such as Git, database schema changes should also be managed in a similar way.</p><p>Other way to accomplish version control for database schema changes is to use tools such as Liquibase or Flyway. These tools allow you to define the database schema as code, in the form of XML, YAML or SQL files, and track changes made to the schema over time. They also provide mechanisms for migrating the schema from one version to another and managing rollbacks if necessary.</p><p>For example, let’s say we have a table called “users” with the following schema:</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">users</span> <span class="p">(</span>
    <span class="n">id</span> <span class="nb">SERIAL</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
    <span class="n">name</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">255</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
    <span class="n">email</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">255</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
    <span class="n">password</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">255</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span>
<span class="p">);</span>
</code></pre></div></div><p>If we need to add a new column to this table, such as “phone_number”, we can create a new Liquibase changelog file called “001_add_phone_number_column.xml” with the following contents:</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;changeSet</span> <span class="na">author=</span><span class="s">"me"</span> <span class="na">id=</span><span class="s">"add_phone_number_column"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;addColumn</span> <span class="na">tableName=</span><span class="s">"users"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;column</span> <span class="na">name=</span><span class="s">"phone_number"</span> <span class="na">type=</span><span class="s">"varchar(255)"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/addColumn&gt;</span>
<span class="nt">&lt;/changeSet&gt;</span>
</code></pre></div></div><p>We can then run Liquibase to apply this change to the database, and it will keep track of the fact that this change has been applied. If we need to roll back this change, we can simply run the tool with the “rollback” command, and Liquibase will automatically generate the SQL necessary to undo the change.</p><p>Another advantage of using version control for database schema changes is that it makes it easier to collaborate with other developers. Just as multiple developers can work on the same codebase simultaneously using Git, multiple developers can also work on the same database schema simultaneously.</p><p>In conclusion, managing database schema changes efficiently is critical to the success of any software project that relies on a database. By following best practices such as using a migration tool, version control, and testing, we can ensure that our database schema changes are made in a controlled and predictable way, with minimal disruption to our applications.</p><div class="tagcloud"><span class="tagcloud-h">Tags:</span> <span class="tagcloud-tag tagcloud-tag-s"><a href="/tag/migration/">migration</a></span> <span class="tagcloud-tag tagcloud-tag-xl"><a href="/tag/posgresql/">posgresql</a></span> <span class="tagcloud-tag tagcloud-tag-xl"><a href="/tag/schema/">schema</a></span></div></main><footer><div class="navigation"> <a class="prev" href="/boosting-postgresql-performance">&laquo; Boosting PostgreSQL Performance</a> <a class="next" href="/the-impact-of-database-schema-changes">The Impact of Database Schema Changes &raquo;</a></div><div class="bottom-footer"><div class="name">Hugh Garnier</div><div class="title">Linux user and software/system security researcher blog website</div></div></footer><!-- <script type="text/x-mathjax-config"> MathJax.Hub.Config({ extensions: ["tex2jax.js", "TeX/AMSmath.js"], jax: ["input/TeX", "output/SVG"], }) </script> <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=default"> </script> -->

<!DOCTYPE html><html lang="en" dir="ltr"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta http-equiv="X-UA-Compatible" content="ie=edge"><title>Boosting PostgreSQL Performance | Hugh Garnier de Blog</title><meta name="description" content="Linux user and software/system security researcher blog website"><link rel="shortcut icon" href="/assets/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/favicon.ico" type="image/x-icon"><link href='/feed.xml' rel='alternate' type='application/atom+xml'><link rel="canonical" href="/boosting-postgresql-performance"><link rel="stylesheet" href="/assets/style.css"><body><main><h2 class="title">Hugh Garnier de Blog</h2><nav> <a href="https://hughmenow.github.io">Home</a> <a href="https://hughmenow.github.io/about">About</a></nav><h1>Boosting PostgreSQL Performance</h1><i>Jan 22, 2023</i><h4 class="subtitle">Learn how to optimize your PostgreSQL database schema to improve query performance and reduce redundancy.</h4><p>As a database architect, I’ve worked with a wide range of database systems over the years, and one of my favorites is PostgreSQL. PostgreSQL is a powerful and flexible database system that’s well-suited to a variety of applications, from small-scale web applications to large-scale enterprise systems.</p><p>One of the key strengths of PostgreSQL is its ability to be tuned for optimal performance. By carefully optimizing the database schema and configuration settings, it’s possible to achieve lightning-fast performance that can help your applications scale to meet the needs of even the most demanding workloads.</p><p>In this article, I’ll share some of my top tips for optimizing PostgreSQL database performance by tuning the database schema. Specifically, I’ll cover three areas of focus: table design, indexing, and query optimization. By following these tips, you’ll be well on your way to achieving optimal performance from your PostgreSQL database.</p><h2 id="table-design">Table Design</h2><p>The design of your database tables can have a significant impact on performance, so it’s important to take care when designing your schema. Here are a few tips to keep in mind:</p><p>Normalize your tables: Normalization is the process of organizing data in a database to reduce redundancy and improve data integrity. By properly normalizing your tables, you can reduce the amount of disk space required for your database and improve performance by minimizing the number of table joins required to fetch data.</p><p>Use appropriate data types: Choosing the right data types for your columns can help improve performance and reduce storage requirements. For example, using smaller integer types instead of larger ones can reduce the amount of storage required for your data, which can help improve performance.</p><p>Avoid excessive column use: It’s tempting to add lots of columns to your tables, but be careful not to go overboard. Having too many columns in a table can slow down queries and increase disk space requirements. Instead, try to keep your tables lean and focused on a specific set of data.</p><h2 id="indexing">Indexing</h2><p>Proper indexing is critical to achieving optimal performance from your PostgreSQL database. Here are a few tips to keep in mind when creating indexes:</p><p>Use the right type of index: PostgreSQL supports several types of indexes, including B-tree, hash, and GiST indexes. Each type of index is optimized for a different type of query, so it’s important to choose the right type of index for your specific needs.</p><p>Index frequently-queried columns: By indexing frequently-queried columns, you can improve query performance and reduce the amount of time required to fetch data.</p><p>Don’t over-index: While it’s important to index frequently-queried columns, be careful not to over-index. Too many indexes can slow down insert and update operations and increase disk space requirements.</p><h2 id="query-optimization">Query Optimization</h2><p>Finally, query optimization is an important part of achieving optimal performance from your PostgreSQL database. Here are a few tips to keep in mind when optimizing your queries:</p><p>Use the EXPLAIN command: The EXPLAIN command can help you understand how PostgreSQL is executing your queries and identify areas for optimization.</p><p>Use subqueries and CTEs: Subqueries and Common Table Expressions (CTEs) can help simplify complex queries and improve performance by reducing the number of joins required to fetch data.</p><p>Avoid expensive operations: Certain operations, such as sorting and aggregation, can be expensive in terms of both time and resources. Whenever possible, try to avoid these operations or use them sparingly.</p><p>Let’s take a look at some examples of how these tips can be applied in practice.</p><h3 id="example-1-normalizing-tables">Example 1: Normalizing Tables</h3><p>Consider a hypothetical e-commerce application that has a database table for storing order information. The initial design of the table looks like this:</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">orders</span> <span class="p">(</span>
    <span class="n">order_id</span> <span class="nb">SERIAL</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span> 
    <span class="n">customer_name</span> <span class="nb">TEXT</span><span class="p">,</span> 
    <span class="n">customer_email</span> <span class="nb">TEXT</span><span class="p">,</span> 
    <span class="n">product_name</span> <span class="nb">TEXT</span><span class="p">,</span> 
    <span class="n">product_description</span> <span class="nb">TEXT</span>
<span class="p">);</span>
</code></pre></div></div><p>As you can see, this table is not fully normalized. There is a lot of redundancy, as the customer information is repeated for every order they place. This can result in a lot of wasted disk space and can slow down queries that need to join the orders table with other tables.</p><p>To normalize this table, we can create separate tables for customers and products and link them to the orders table using foreign keys. Here’s what the revised schema might look like:</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">customers</span> <span class="p">(</span>
    <span class="n">customer_id</span> <span class="nb">SERIAL</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span> 
    <span class="n">customer_name</span> <span class="nb">TEXT</span><span class="p">,</span> <span class="n">customer_email</span> <span class="nb">TEXT</span>
<span class="p">);</span>

<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">products</span> <span class="p">(</span>
    <span class="n">product_id</span> <span class="nb">SERIAL</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span> 
    <span class="n">product_name</span> <span class="nb">TEXT</span><span class="p">,</span> 
    <span class="n">product_price</span> <span class="nb">NUMERIC</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="p">);</span> 

<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">orders</span> <span class="p">(</span>
    <span class="n">order_id</span> <span class="nb">SERIAL</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span> 
    <span class="n">customer_id</span> <span class="nb">INTEGER</span> <span class="k">REFERENCES</span> <span class="n">customers</span> <span class="p">(</span><span class="n">customer_id</span><span class="p">),</span> 
    <span class="n">product_id</span> <span class="nb">INTEGER</span> <span class="k">REFERENCES</span> <span class="n">products</span> <span class="p">(</span><span class="n">product_id</span><span class="p">),</span> 
    <span class="n">quantity</span> <span class="nb">INTEGER</span><span class="p">,</span> 
    <span class="n">order_date</span> <span class="nb">TIMESTAMP</span>
<span class="p">);</span>
</code></pre></div></div><p>As you can see, we’ve created separate tables for customers and products and linked them to the orders table using foreign keys. This eliminates redundancy and makes it easier to query and join data across multiple tables.</p><h3 id="example-2-indexing-frequently-queried-columns">Example 2: Indexing Frequently-Queried Columns</h3><p>Consider a hypothetical database for a social media application that has a table for storing user posts. The table includes columns for the post ID, the user ID of the person who made the post, the text of the post, and the timestamp of when the post was made.</p><p>If we frequently need to query posts by user ID, it makes sense to create an index on the user_id column. Here’s an example of how to create the index:</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">INDEX</span> <span class="n">idx_user_id</span> <span class="k">ON</span> <span class="n">posts</span> <span class="p">(</span><span class="n">user_id</span><span class="p">);</span>
</code></pre></div></div><p>This will create a B-tree index on the user_id column, which can significantly speed up queries that filter by user ID.</p><h3 id="example-3-using-subqueries-and-ctes">Example 3: Using Subqueries and CTEs</h3><p>Consider a hypothetical database for a blog application that has a table for storing blog posts and a table for storing comments on those posts. Suppose we want to retrieve a list of all blog posts along with the number of comments on each post.</p><p>One way to do this is with a subquery:</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> 
    <span class="n">posts</span><span class="p">.</span><span class="o">*</span><span class="p">,</span> 
    <span class="p">(</span><span class="k">SELECT</span> <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">comments</span> <span class="k">WHERE</span> <span class="n">post_id</span> <span class="o">=</span> <span class="n">posts</span><span class="p">.</span><span class="n">post_id</span><span class="p">)</span> <span class="k">AS</span> <span class="n">comment_count</span> 
<span class="k">FROM</span> 
    <span class="n">posts</span><span class="p">;</span>
</code></pre></div></div><p>This subquery will count the number of comments for each post by filtering the comments table based on the post_id column.</p><p>Another way to do this is with a Common Table Expression (CTE):</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">WITH</span> <span class="n">comment_counts</span> <span class="k">AS</span> <span class="p">(</span>
    <span class="k">SELECT</span> <span class="n">post_id</span><span class="p">,</span> <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">AS</span> <span class="k">count</span> <span class="k">FROM</span> <span class="n">comments</span> <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">post_id</span>
<span class="p">)</span> <span class="k">SELECT</span> 
      <span class="n">posts</span><span class="p">.</span><span class="o">*</span><span class="p">,</span> 
      <span class="n">comment_counts</span><span class="p">.</span><span class="k">count</span> <span class="k">AS</span> <span class="n">comment_count</span> 
<span class="k">FROM</span> 
    <span class="n">posts</span> <span class="k">LEFT</span> <span class="k">JOIN</span> <span class="n">comment_counts</span> <span class="k">ON</span> <span class="n">posts</span><span class="p">.</span><span class="n">post_id</span> <span class="o">=</span> <span class="n">comment_counts</span><span class="p">.</span><span class="n">post_id</span><span class="p">;</span>
</code></pre></div></div><p>This CTE first calculates the comment count for each post using a GROUP BY query, then joins the results of that query with the posts table to produce the final result set. This approach can be more efficient than using a subquery, particularly if you need to perform more complex calculations on the comment count data.</p><p>By following these tips for optimizing PostgreSQL database performance by tuning the database schema, you’ll be well on your way to achieving optimal performance from your PostgreSQL database. Remember, performance tuning is an ongoing process, so be sure to monitor your database’s performance over time and make adjustments as needed to ensure that your applications are running smoothly and efficiently.</p><div class="tagcloud"><span class="tagcloud-h">Tags:</span> <span class="tagcloud-tag tagcloud-tag-l"><a href="/tag/performance/">performance</a></span> <span class="tagcloud-tag tagcloud-tag-xl"><a href="/tag/posgresql/">posgresql</a></span> <span class="tagcloud-tag tagcloud-tag-xl"><a href="/tag/schema/">schema</a></span></div></main><footer><div class="navigation"> <a class="prev" href="/the-aftermath-of-log4">&laquo; The Aftermath of Log4</a> <a class="next" href="/tools-for-postgresql-schema-managements">Tools for PostgreSQL Schema Managements &raquo;</a></div><div class="bottom-footer"><div class="name">Hugh Garnier</div><div class="title">Linux user and software/system security researcher blog website</div></div></footer><!-- <script type="text/x-mathjax-config"> MathJax.Hub.Config({ extensions: ["tex2jax.js", "TeX/AMSmath.js"], jax: ["input/TeX", "output/SVG"], }) </script> <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=default"> </script> -->
